# 设计模式：
## 模式一：单例模式 singleton
[敖丙-设计模式系列 - 单例模式](https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ)
单例：在当前进程中，通过单例模式创建的类有且只有一个实例。
单例特点：
 - 在Java应用中，单例模式能保证在一个JVM中，该对象只有一个实例存在
 - 构造器必须时私有的，外部类无法通过调用构造器方法创建该实例
 - 没有公开的set方法，外部类无法调用set方法创建该实例
 - 提供一个公开的get方法获取唯一的这个实例

单例好处：
 - 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销
 - 省去了new操作符，降低了系统内存的使用频率，减轻GC压力
 - 系统中某些类，如spring里的controller，控制着处理流程，如果该类可以创建多个的话，系统完全乱了
 - 避免对资源的重复占用
   

单例模式的8种写法
1. 饿汉式(静态常量) 可用 Singleton1.java
2. 饿汉式(静态代码块) 可用 Singleton2.java
3. 懒汉式(线程不安全) 不可用
4. 懒汉式(线程安全，同步方法) 不推荐用
5. 懒汉式(线程不安全，同步代码块) 不可用
6. 双重检查 推荐使用 Singleton6.java

优点：线程安全；延迟加载；效率较高

问题1：为什么要double-check？
 a、线程安全；
 b、性能问题，多线程访问不能及时响应

问题2：为什么要用volatile
 a、新建对象实际上有3个步骤（非原子操作）
 b、防止重排序带来的NPE（空指针）问题。

7. 静态内部类 推荐使用 Singleton7.java  线程安全 懒加载
8. 枚举 推荐使用————生产实践最佳写法 Singleton8.java 可以防止反序列化重新创建新的对象

## 模式二：代理模式 proxy
动态代理：cglib jdk；静态代理

## 模式三：工厂模式

## 模式四：抽象工厂模式

## 模式五：策略模式

## 模式六：模版模式

## 模式七：建造者模式

## 模式八：观察者模式

[]: https://mp.weixin.qq.com/s/dW0L-PoBeTFHhD29HJO0BQ