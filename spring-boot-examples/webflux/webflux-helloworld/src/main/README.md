## 为什么需要响应式编程？
随着并发量高，软件的性能出现瓶颈。
解决并发问题的手段：
- 并行化：使用更多的线程和更多的硬件资源
- 在如何使用现有资源方面寻求更高的效率；

并行化方法并不是什么灵丹妙药，使用阻塞代码编程。在出现性能瓶颈之前，这种做法没有问题，此时就需要引入额外的线程，来运行相似的阻塞代码。
但是，这种资源利用率的扩展可能很快引来争用和并发问题。

上面提到的第二种方法是寻求更高的效率，可以解决资源浪费问题。通过编写异步非阻塞代码，可以将执行切换到另一个使用相同底层资源的活动任务上，
在异步执行完成后返回到当前程序。

如何在JVM上编写异步代码呢？Java提供了两种异步编程模型：
- Callbacks：异步方法没有返回值，但是提供一个额外的回调参数（一个lambda或者匿名类对象），当结果可用时调用该参数。
- Futures：异步方法立即返回一个Future<T>对象。异步线程计算一个T值，Future对象封装对它的访问。该值不是立即可用的，但可以轮询Future对象，直到该值可用为止。

这些技术足够好吗？并不是每个场景都适用，而且两种方式都有限制。

回调是很难组合在一起的，很快就会导致难以阅读和维护的代码（称为”回调地狱”）。

Futures比回调稍微好一点，但是在组合方面依然做的不够好，即使Java 8中引入了CompletableFuture。
把多个Future编排到一起虽然可行，但是并不容易。而且，Future还有另外的问题：通过调用get()方法，很容易让Future对象进入到另一种阻塞情景；
它们不支持延时计算；不支持多值和高级错误处理。

#响应式编程
响应式编程 VS 命令式编程

响应式编程是一种异步的、声名式的、面向数据流的编程范式。

一个流就是一个将要发生的以时间为序的事件序列。
它能发射出三种不同的东西：一个数据值（data value）(某种类型的)，一个错误（error）或者一个“完成（completed）”的信号。

我们只能异步地捕获这些发出的事件：定义一个针对数据值的函数，在发出一个值时，该函数就会异步地执行；针对发出错误时的函数；还有针对发出‘完成’时的函数。
有时你可以省略这最后两个函数，只专注于针对数据值的函数。“监听”流的行为叫做订阅。

我们定义的这些函数就是观察者。这个流就是被观察的主体(subject)（或“可观察的(observable)”）。这正是观察者设计模式。

## 变化传递
一个单元格变化之后，会像多米诺骨牌一样，导致直接和间接引用它的其他单元格均发生相应变化。

## 数据流
这些数据/事件在响应式编程里会以数据流的形式发出。

## 声明式

### 从命令式编程到响应式编程
响应式编程库解决的问题：
 - 可组合性和可读性
 - 使用丰富的操作符词汇操作数据流； 
 - 在订阅数据流之前什么也不会发生（延时计算）；
 - 背压（backpressure）或消费者向生产者发送发射速率过快的信号的能力；
 - 与并发无关的高级抽象；

所谓响应式就是外界发生了变化，你要做出反应。所以响应式编程就是围绕着变化来构建的。

如何收集到原始变化，如何把这个变化告知相关处理者，处理者如何做出反应，做出反应的过程其实就是引发了新的变化，
这个新的变化又该如何被收集，又该如何告知下一个处理者，如此往复，直至全部结束。

响应式的两个问题，一是如何知道外界的变化（How），二是如何对这种变化作出反应（What）。

如何知道变化，那就让别人告诉你呗。如何做出反应，那就执行一段逻辑代码呗。

别人告诉你就等于异步回调/通知，执行的这段逻辑代码，可以是外界传入的，也可以是自己本身的一个方法。

### 传统的同步编程
在传统的编码中，会将逻辑处理代码写成方法，需要的数据由方法参数传入，处理过的数据由方法的返回值返回。

执行时以main方法为入口点启动，按照一定的顺序执行这些方法，数据依次流入流出每个方法，当所有的方法执行完时，数据也处理完了，就结束了。

整个过程是以逻辑代码的执行为主线，数据只是一个必须的参与者而已，因为代码要处理数据，如果数据不到位，代码就停下来不执行，等待数据的到来。

这就是典型的同步阻塞式的执行过程，非常简单，易于理解，而且代码也很好写。

响应式是异步非阻塞，和同步阻塞应该是相对的。

响应式关注两点，变化和反应，而且是变化在前，反应在后。同步阻塞也关注两点，执行逻辑和数据，而且是执行逻辑在前，数据在后

那就开始建立对应关系。因为“反应”是一系列行为动作，所以应该和“执行逻辑”对应。那“变化”只能和“数据”对应，其实这是对的，
“数据”由不可用到可用，本身就是发生了一个“变化”。

这个对应关系建立的很完美，但是逻辑顺序却完全冲突。响应式是由变化主导反应，这很好理解，我都没有变化，你无须做出反应。
同步阻塞是由执行逻辑主导数据，这也很好理解，我代码都没执行呢，根本不需要数据。

可见，它们的对应关系非常完美，但主导顺序完全相反。

原来以逻辑代码执行作为主线，数据作为参与者。现在以数据作为主线，逻辑代码执行作为参与者。说的再白一些，原来是数据传递到逻辑代码里，现在是逻辑代码传递到数据里。

逻辑代码怎么传递？哈哈，Lambda表达式呀，函数式编程呀。

想象一下，有一个长长的管子，里面的水一直在流。

如果你想让水变成橙色的，只需在管子上开个口，加装一个可以持续投放橙色染料的装置，结果流经它的水都变成橙色的了。

如果你想让橙色的水变甜的话，只需在后面的管子上开个口，加装一个可以持续投放白糖的装置，结果流经它的水都变成甜的了。

同理，可以在后面继续加装投放柠檬酸的装置，让水变酸，在后面继续加装压入二氧化碳的装置，让水带气泡。

最后发现，自来水经过多道工序处理后变成了芬达。

如果把水流看作是数据流，把投放装置看作是逻辑代码，就变成了，数据先流入第一个逻辑代码，处理后再流入第二个逻辑代码，依次流下去直至结束。

这就是以数据作为主线，逻辑代码只是参与者，同时它也是Reactor实现响应式编程的原理，Spring官方使用的响应式类库就是Reactor。

阻塞 -> 非阻塞 NIO
逻辑代码怎么传递 -> 函数式编程
观察者模式


什么是响应式编程？
举个例子 简单带入。

为什么会出现？传统的同步编程有什么问题？
响应式编程解决了那些问题？
包含那些原理？底层有几大块？

写一个例子实现。


响应编程能够简化编程，它依赖于事件，代码运行的顺序不是代码行的顺序，而是和一个以上的事件有关，这些事件发生是以随着时间的推移的序列。我们把这一系列事件称为“流”。



-----------
背压
Flux（对应多值）和Mono（单值）尤其是方法的参数和返回值。即便是空返回值，也应封装为Mono<Void>。
这样做的目的是，使得应用能够以一种统一的符合 RP 规范的方式处理数据，最理想的情况是从最底层的数据库（或者其他系统外部调用），
到最上层的 Controller 层，所有数据都不落地，经由各种 Flux 和 Mono 铺设的“管道”，直供调用端。